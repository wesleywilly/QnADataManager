/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package dataModel;

import WebCrawlers.Zenodotus;
import nlp.StopWords;
import java.util.ArrayList;
import java.util.List;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

/**
 * Represents a word from a sentence.
 *
 * @author @wesleywilly [https://github.com/wesleywilly]
 */
public class Word {

    private static final String VALUE = "value";
    private static final String TAG = "tag";
    private static final String LENGTH = "length";

    private static final String SUBCATEGORY = "subcategory";
    private static final String CONTAINED_IN_A_CATEGORY = "contained_in_a_category";
    private static final String CONTAINED_IN_A_CATEGORY_INSTANCE = "contained_in_a_category_instance";
    private static final String CONTAINED_IN_A_RELATION = "contained_in_a_relation";

    private static final String CATEGORIES = "categories";
    private static final String CATEGORY_INSTANCES = "category_instances";
    private static final String RELATIONS = "relations";

    private static final String NW_TAG = "nw_tag";
    private static final String NW_IC_CATEGORY = "nw_ic_category";
    private static final String NW_IC_CATEGORY_INSTANCE = "nw_ic_category_instance";
    private static final String NW_IC_RELATION = "nw_ic_relation";

    private static final String NW_CATEGORIES = "nw_categories";
    private static final String NW_CATEGORY_INSTANCES = "nw_category_instances";
    private static final String NW_RELATIONS = "nw_relations";

    private static final String SNW_TAG = "snw_tag";
    private static final String SNW_IC_CATEGORY = "snw_ic_category";
    private static final String SNW_IC_CATEGORY_INSTANCE = "snw_ic_category_instance";
    private static final String SNW_IC_RELATION = "snw_ic_relation";

    private static final String SNW_CATEGORIES = "snw_categories";
    private static final String SNW_CATEGORY_INSTANCES = "snw_category_instances";
    private static final String SNW_RELATIONS = "snw_relations";

    private static final String LW_TAG = "lw_tag";
    private static final String LW_IC_CATEGORY = "lw_ic_category";
    private static final String LW_IC_CATEGORY_INSTANCE = "lw_ic_category_instance";
    private static final String LW_IC_RELATION = "lw_ic_relation";

    private static final String LW_CATEGORIES = "lw_categories";
    private static final String LW_CATEGORY_INSTANCES = "lw_category_instances";
    private static final String LW_RELATIONS = "lw_relations";

    private static final String PUW_TAG = "puw_tag";
    private static final String PUW_IC_CATEGORY = "puw_ic_category";
    private static final String PUW_IC_CATEGORY_INSTANCE = "puw_ic_category_instance";
    private static final String PUW_IC_RELATION = "puw_ic_relation";

    private static final String PUW_CATEGORIES = "puw_categories";
    private static final String PUW_CATEGORY_INSTANCES = "puw_category_instances";
    private static final String PUW_RELATIONS = "puw_relations";

    private String value;
    private String tag;
    private long length;
    private boolean stopword;

    private boolean subcategory;
    private boolean containedInACategory;
    private boolean containedInACategoryInstance;
    private boolean containedInARelation;

    private List<String> categories;
    private List<String> categoryInstances;
    private List<String> relations;

    //Informations about neibourhood
    /**
     * Informations about some attributes:
     *
     * nwic = next word is contained in a ... snwic = second next word is
     * contained in a ... lwic = last word is contained in a ... puwic =
     * penultimate word is contained in a ...
     *
     *
     */
    private String nwTag;
    private boolean nwicCategory;
    private boolean nwicCategoryInstance;
    private boolean nwicRelation;

    private String snwTag;
    private boolean snwicCategory;
    private boolean snwicCategoryInstance;
    private boolean snwicRelation;

    private String lwTag;
    private boolean lwicCategory;
    private boolean lwicCategoryInstance;
    private boolean lwicRelation;

    private String puwTag;
    private boolean puwicCategory;
    private boolean puwicCategoryInstance;
    private boolean puwicRelation;

    /**
     * Builds the object.
     *
     * @param value = the word itself.
     * @param tag = Stores tag generated by the stanford parser.
     */
    public Word(String value, String tag) {
        this.value = value;
        this.tag = tag;
        this.length = value.length();
        semanticAnalysis();
    }

    /**
     * Builds the object. StanfordTag = null;
     *
     * @param value = the word itself.
     */
    public Word(String value) {
        this.value = value;
        this.tag = "";
        this.length = value.length();
        subcategory = false;
        semanticAnalysis();
    }

    /**
     * Constructs the object from a JSONObject. The JSONObject with same data
     * structure can be generated by toJSON method in this class.
     *
     * @param jWord = JSONObject with a similar data structure
     */
    public Word(JSONObject jWord) {

        this.value = (String) jWord.get(VALUE);
        this.length = (long) jWord.get(LENGTH);
        this.tag = (String) jWord.get(TAG);
        this.stopword = isStopword();

        if (jWord.containsKey(SUBCATEGORY)) {
            this.subcategory = (boolean) jWord.get(SUBCATEGORY);
        } else {
            this.subcategory = false;
        }

        this.categories = jSONArrayToStringList((JSONArray) jWord.get(CATEGORIES));
        this.categoryInstances = jSONArrayToStringList((JSONArray) jWord.get(CATEGORY_INSTANCES));;
        this.relations = jSONArrayToStringList((JSONArray) jWord.get(RELATIONS));

        this.containedInACategory = (boolean) jWord.get(CONTAINED_IN_A_CATEGORY);
        this.containedInACategoryInstance = (boolean) jWord.get(CONTAINED_IN_A_CATEGORY_INSTANCE);
        this.containedInARelation = (boolean) jWord.get(CONTAINED_IN_A_RELATION);

        /*
        this.lwTag = null;
        this.lwicCategory = null;
        this.lwicCategoryInstance = null;
        this.lwicRelation = null;
        
        this.nwTag = null;
        this.nwicCategory = null;
        this.nwicCategoryInstance = null;
        this.nwicRelation = null;
        
        this.puwTag = null;
        this.puwicCategory = null;
        this.puwicCategoryInstance = null;
        this.puwicRelation = null;
        
        this.snwTag = null;
        this.snwicCategory = null;
        this.snwicCategoryInstance = null;
        this.snwicRelation = null;
         */
    }

    /**
     * Returns a JSONObject with a similar data structure of this Object
     *
     * @return JSONObject
     */
    public JSONObject toJSON() {
        if (!stopword) {
            JSONObject jWord = new JSONObject();
            if (!value.isEmpty() && value != null) {
                jWord.put(VALUE, value);
                jWord.put(LENGTH, length);
                if (!tag.isEmpty() && tag != null) {
                    jWord.put(TAG, tag);
                }
                jWord.put(CONTAINED_IN_A_CATEGORY, isContainedInACategory());
                if (isContainedInACategory()) {
                    jWord.put(CATEGORIES, stringListToJSONArray(categories));
                }
                jWord.put(CONTAINED_IN_A_CATEGORY_INSTANCE, isContainedInACategoryInstance());
                if (isContainedInACategoryInstance()) {
                    jWord.put(CATEGORY_INSTANCES, stringListToJSONArray(categoryInstances));
                }

                jWord.put(CONTAINED_IN_A_RELATION, isContainedInARelation());
                if (isContainedInARelation()) {
                    jWord.put(RELATIONS, stringListToJSONArray(relations));
                }
                jWord.put(SUBCATEGORY, subcategory);
            }
            return jWord;
        } else {
            return null;
        }
    }

    public boolean isStopword() {
        return stopword;
    }

    /**
     * Returns the word value
     */
    public String getValue() {
        return value;
    }

    /**
     * Returns the tag generated by the stanford parser for this word.
     */
    public String getTag() {
        return tag;
    }

    /**
     * Set the tag generated by the stanford parser for this word.
     *
     * @param tag
     */
    public void setTag(String tag) {
        this.tag = tag;
    }

    private JSONArray stringListToJSONArray(List<String> stringList) {
        JSONArray jList = new JSONArray();

        for (String string : stringList) {
            jList.add(string);
        }

        return jList;
    }

    private List<String> jSONArrayToStringList(JSONArray jList) {
        List<String> stringList = new ArrayList<>();
        if (jList != null) {
            for (Object object : jList) {
                stringList.add((String) object);
            }
        }
        return stringList;
    }

    public boolean isSubcategory() {
        return subcategory;
    }

    public void setSubcategory(boolean subcategory) {
        this.subcategory = subcategory;
    }

    public long getLength() {
        return length;
    }

    public boolean isContainedInACategory() {
        return containedInACategory;
    }

    public boolean isContainedInACategoryInstance() {
        return containedInACategoryInstance;
    }

    public boolean isContainedInARelation() {
        return containedInARelation;
    }

    public List<String> getCategories() {
        return categories;
    }

    public List<String> getCategoryInstances() {
        return categoryInstances;
    }

    public List<String> getRelations() {
        return relations;
    }

    public boolean isNwicCategory() {
        return nwicCategory;
    }

    public boolean isNwicCategoryInstance() {
        return nwicCategoryInstance;
    }

    public boolean isNwicRelation() {
        return nwicRelation;
    }

    public boolean isSnwicCategory() {
        return snwicCategory;
    }

    public boolean isSnwicCategoryInstance() {
        return snwicCategoryInstance;
    }

    public boolean isSnwicRelation() {
        return snwicRelation;
    }

    public boolean isLwicCategory() {
        return lwicCategory;
    }

    public boolean isLwicCategoryInstance() {
        return lwicCategoryInstance;
    }

    public boolean isLwicRelation() {
        return lwicRelation;
    }

    public boolean isPuwicCategory() {
        return puwicCategory;
    }

    public boolean isPuwicCategoryInstance() {
        return puwicCategoryInstance;
    }

    public boolean isPuwicRelation() {
        return puwicRelation;
    }

    public String getNwTag() {
        return nwTag;
    }

    public String getSnwTag() {
        return snwTag;
    }

    public String getLwTag() {
        return lwTag;
    }

    public String getPuwTag() {
        return puwTag;
    }

    private void semanticAnalysis() {
        //Stop-words
        if (!StopWords.contains(value)) {

            //Category
            containedInACategory = false;
            categories = new ArrayList<>();
            try {
                JSONArray categoryResult = Zenodotus.searchCategory(value);
                if (categoryResult != null && categoryResult.size() > 0) {
                    for (Object object : categoryResult) {
                        JSONObject jObject = (JSONObject) object;
                        categories.add((String) jObject.get("category_name"));
                    }
                    containedInACategory = true;
                    categoryResult = null;
                }

            } catch (Exception e) {
                System.out.println("[WORD] Error: While acessing NELL KB.");
                e.printStackTrace();
            }

            //Category Instance
            containedInACategoryInstance = false;
            categoryInstances = new ArrayList<>();
            try {
                JSONArray categoryInstanceResult = Zenodotus.searchCategoryInstance(value);
                if (categoryInstanceResult != null && categoryInstanceResult.size() > 0) {
                    for (Object object : categoryInstanceResult) {
                        JSONObject jObject = (JSONObject) object;
                        String instance_name = (String) jObject.get("instance_name");
                        categoryInstances.add(instance_name);

                    }
                    containedInACategoryInstance = true;
                    categoryInstanceResult = null;
                }

            } catch (Exception e) {
                System.out.println("[WORD] Error: While acessing NELL KB.");
                e.printStackTrace();
            }

            //Relation
            containedInARelation = false;
            relations = new ArrayList<>();
            try {
                JSONArray relationsResult = Zenodotus.searchRelation(value);
                if (relationsResult != null && relationsResult.size() > 0) {
                    for (Object object : relationsResult) {
                        JSONObject jObject = (JSONObject) object;
                        relations.add((String) jObject.get("relation_name"));
                    }
                    containedInARelation = true;
                    relationsResult = null;
                }

            } catch (Exception e) {
                System.out.println("[WORD] Error: While acessing NELL KB.");
                e.printStackTrace();
            }

        } else {
            stopword = true;
        }
    }

    /**
     * Collect informations of a word (by parameter) an store informations: -
     * Tag - contained in a Category - contained in a Relations - contained in a
     * Category instance
     *
     * @param word - the word that have informations
     * @param position - An integer that should be one of these numbers {-2, -1,
     * 1, 2}, represents the position of the word that has the informations
     */
    public void collectInformation(Word word, int position) {
        switch (position) {
            case -2:
                puwTag = word.getTag();
                puwicCategory = word.isContainedInACategory();
                puwicCategoryInstance = word.isContainedInACategoryInstance();
                puwicRelation = word.isContainedInARelation();
                break;
            case -1:
                lwTag = word.getLwTag();
                lwicCategory = word.isContainedInACategory();
                lwicCategoryInstance = word.isContainedInACategoryInstance();
                lwicRelation = word.isContainedInARelation();
                break;
            case 1:
                nwTag = word.getLwTag();
                nwicCategory = word.isContainedInACategory();
                nwicCategoryInstance = word.isContainedInACategoryInstance();
                nwicRelation = word.isContainedInARelation();
                break;
            case 2:
                snwTag = word.getLwTag();
                snwicCategory = word.isContainedInACategory();
                snwicCategoryInstance = word.isContainedInACategoryInstance();
                snwicRelation = word.isContainedInARelation();
                break;

        }
    }

}
